generator client {
  provider     = "prisma-client-js"
  moduleFormat = "cjs"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  user
  admin
  landlord
}

enum ReceiptStatus {
  awaitingFeedback
  pending
  approved
  rejected
}

enum FeedbackType {
  single
  multiple
}

enum FeedbackStatus {
  inProgress
  completed
}

enum RedemptionStatus {
  pending
  approved
  completed
  rejected
}

model User {
  id        String @id @default(uuid())
  firstName String
  lastName  String

  email     String  @unique
  password  String?
  city      String?
  street    String?
  apartment String?
  avatarUrl String?

  role          UserRole @default(user)
  pointsBalance Int      @default(0)
  createdAt     DateTime @default(now())

  googleId String? @unique

  receipts             Receipt[]
  feedbackResults      FeedbackResult[]
  forgotPasswordTokens ForgotPasswordToken[]
  redemptions          Redemption[]
}

model ForgotPasswordToken {
  id String @id @default(cuid())

  userId String @unique()
  user   User   @relation(fields: [userId], references: [id])

  token String

  createdAt DateTime @default(now())
  expiresAt DateTime
}

model Receipt {
  id         String        @id @default(uuid())
  receiptUrl String
  status     ReceiptStatus @default(awaitingFeedback)

  createdAt  DateTime  @default(now())
  approvedAt DateTime?

  comment String?

  userId String
  user   User   @relation(fields: [userId], references: [id])

  feedbackResult FeedbackResult?
}

model FeedbackQuestion {
  id         String       @id @default(uuid())
  type       FeedbackType
  
  createdAt  DateTime     @default(now())

  options         FeedbackOption[]
  translations    FeedbackQuestionTranslation[]
  feedbackAnswers FeedbackAnswer[]
  feedbackResults FeedbackResult[]

  surveyQuestions SurveyQuestion[]
}

model FeedbackQuestionTranslation {
  id        String   @id @default(uuid())
  language  String
  text      String
  createdAt DateTime @default(now())

  questionId String
  question   FeedbackQuestion @relation(fields: [questionId], references: [id])

  @@unique([questionId, language])
}

model FeedbackResult {
  id        String         @id @default(uuid())
  receiptId String         @unique()
  userId    String
  status    FeedbackStatus @default(inProgress)

  surveyId String
  survey   FeedbackSurvey @relation(fields: [surveyId], references: [id])

  totalQuestions    Int
  answeredQuestions Int @default(0)
  pointsValue       Int @default(0)

  currentQuestionId String?
  currentQuestion   FeedbackQuestion? @relation(fields: [currentQuestionId], references: [id])

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  completedAt DateTime?

  user    User             @relation(fields: [userId], references: [id])
  receipt Receipt          @relation(fields: [receiptId], references: [id])
  answers FeedbackAnswer[]

  @@unique([userId, receiptId])
}

model FeedbackAnswer {
  id               String   @id @default(uuid())
  feedbackResultId String
  questionId       String
  answerKeys       String[]
  createdAt        DateTime @default(now())

  feedbackResult FeedbackResult   @relation(fields: [feedbackResultId], references: [id])
  question       FeedbackQuestion @relation(fields: [questionId], references: [id])

  @@unique([feedbackResultId, questionId])
}

model FeedbackOption {
  id        String   @id @default(uuid())
  key       String
  order     Int
  score     Int?
  createdAt DateTime @default(now())

  questionId String
  question   FeedbackQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)

  translations FeedbackOptionTranslation[]

  @@unique([questionId, key])
  @@unique([questionId, order])
}

model FeedbackOptionTranslation {
  id       String @id @default(uuid())
  language String
  label    String

  optionId String
  option   FeedbackOption @relation(fields: [optionId], references: [id], onDelete: Cascade)

  @@unique([optionId, language])
}

model FeedbackSurvey {
  id       String  @id @default(uuid())
  name     String
  isActive Boolean @default(false)

  startPoints     Int @default(100) // Base points for downloading the receipt
  pointsPerAnswer Int @default(100) // Points for each answer to the question

  createdAt       DateTime         @default(now())
  feedbackResults FeedbackResult[]
  surveyQuestions SurveyQuestion[]

  // Only one survey can have isActive = true.
  // Implemented via custom SQL migration:
  // 'only_one_active_feedback_survey'
}

model SurveyQuestion {
  id String @id @default(uuid())

  surveyId   String
  questionId String

  order     Int
  createdAt DateTime @default(now())

  survey   FeedbackSurvey   @relation(fields: [surveyId], references: [id], onDelete: Cascade)
  question FeedbackQuestion @relation(fields: [questionId], references: [id], onDelete: Restrict)

  @@unique([questionId, surveyId])
  @@unique([surveyId, order])
}

model Redemption {
  id        String           @id @default(uuid())
  userId    String
  user      User             @relation(fields: [userId], references: [id])

  pointsAmount Int
  dollarAmount Decimal        @db.Decimal(10, 2)
  paymentEmail  String

  status          RedemptionStatus @default(pending)
  createdAt       DateTime         @default(now())
  approvedAt      DateTime?
  completedAt     DateTime?
  rejectedAt      DateTime?
  rejectionReason String?
  adminComment    String?
}
